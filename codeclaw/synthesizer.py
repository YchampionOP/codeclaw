"""CODECLAW.md synthesizer — analyze synced sessions and write a project summary file."""

from __future__ import annotations

import json
import re
from collections import Counter, defaultdict
from datetime import datetime, timezone
from pathlib import Path

CODECLAW_MD_HEADER = "<!-- AUTO-GENERATED by CodeClaw. Do not edit manually. -->"
MAX_LINES = 200


def _load_sessions_from_jsonl(path: Path) -> list[dict]:
    sessions: list[dict] = []
    if not path.exists():
        return sessions
    with open(path, encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                sessions.append(json.loads(line))
            except json.JSONDecodeError:
                continue
    return sessions


def _extract_tool_sequences(sessions: list[dict]) -> list[list[str]]:
    """Return list of tool-name sequences, one per session."""
    sequences: list[list[str]] = []
    for session in sessions:
        seq: list[str] = []
        for msg in session.get("messages", []):
            for tu in msg.get("tool_uses", []):
                tool = str(tu.get("tool", "")).strip()
                if tool:
                    seq.append(tool)
        if seq:
            sequences.append(seq)
    return sequences


def _extract_error_patterns(sessions: list[dict]) -> Counter:
    """Count recurring error signatures across sessions."""
    errors: Counter = Counter()
    error_re = re.compile(
        r"(error|exception|traceback|failed|cannot|no such file)",
        re.IGNORECASE,
    )
    for session in sessions:
        seen_in_session: set[str] = set()
        for msg in session.get("messages", []):
            content = str(msg.get("content", ""))
            for line in content.splitlines():
                if error_re.search(line):
                    key = line.strip()[:80]
                    if key and key not in seen_in_session:
                        seen_in_session.add(key)
                        errors[key] += 1
    return errors


def _extract_conventions(sessions: list[dict]) -> list[str]:
    """Pull short imperative sentences from assistant messages as conventions."""
    convention_re = re.compile(
        r"(?:always|never|use|prefer|avoid|make sure|ensure|don't|do not)\s.{10,80}",
        re.IGNORECASE,
    )
    found: dict[str, int] = {}
    for session in sessions:
        for msg in session.get("messages", []):
            if msg.get("role") != "assistant":
                continue
            content = str(msg.get("content", ""))
            for match in convention_re.findall(content):
                key = match.strip().rstrip(".,;")
                if key:
                    found[key] = found.get(key, 0) + 1
    # Return top conventions seen in multiple sessions
    return [k for k, v in sorted(found.items(), key=lambda x: -x[1]) if v >= 2][:10]


def _effective_tool_sequences(sequences: list[list[str]]) -> list[tuple[str, ...]]:
    """Return the most common 2-grams of tool calls."""
    bigrams: Counter = Counter()
    for seq in sequences:
        for i in range(len(seq) - 1):
            bigrams[(seq[i], seq[i + 1])] += 1
    return [pair for pair, count in bigrams.most_common(10) if count >= 2]


def _compute_dataset_health(sessions: list[dict]) -> dict:
    trajectory_counts: Counter = Counter()
    for session in sessions:
        ttype = session.get("trajectory_type", "unknown")
        trajectory_counts[ttype] += 1
    total = len(sessions)
    return {
        "total_sessions": total,
        "trajectory_counts": dict(trajectory_counts),
    }


def synthesize(sessions: list[dict], project_name: str, project_root: Path) -> Path:
    """Analyze *sessions* and write ``CODECLAW.md`` under *project_root*.

    Returns the path to the written file.
    """
    now = datetime.now(tz=timezone.utc).strftime("%Y-%m-%d")
    health = _compute_dataset_health(sessions)
    total = health["total_sessions"]
    trajectory_counts = health["trajectory_counts"]

    # --- Recurring bugs ---
    error_counter = _extract_error_patterns(sessions)
    top_errors = [(msg, cnt) for msg, cnt in error_counter.most_common(10) if cnt >= 2]

    # --- Conventions ---
    conventions = _extract_conventions(sessions)

    # --- Effective tool sequences ---
    tool_sequences = _extract_tool_sequences(sessions)
    effective = _effective_tool_sequences(tool_sequences)

    lines: list[str] = [
        CODECLAW_MD_HEADER,
        f"# CODECLAW — {project_name}",
        f"_Auto-generated {now} from {total} synced session(s). Do not edit._",
        "",
    ]

    # Dataset health
    lines += [
        "## Dataset Health",
        "",
        f"| Metric | Value |",
        f"|--------|-------|",
        f"| Total sessions | {total} |",
    ]
    for ttype, cnt in sorted(trajectory_counts.items(), key=lambda x: -x[1]):
        lines.append(f"| {ttype} | {cnt} |")
    lines.append("")

    # Recurring bugs
    if top_errors:
        lines += ["## Recurring Bugs", ""]
        for msg, cnt in top_errors[:8]:
            safe = msg.replace("|", "\\|")
            lines.append(f"- ({cnt}×) `{safe}`")
        lines.append("")

    # Conventions
    if conventions:
        lines += ["## Repo Conventions", ""]
        for conv in conventions[:8]:
            lines.append(f"- {conv}")
        lines.append("")

    # Effective tool sequences
    if effective:
        lines += ["## Effective Tool-Call Sequences", ""]
        for pair in effective[:8]:
            lines.append(f"- `{pair[0]}` → `{pair[1]}`")
        lines.append("")

    # Trim to MAX_LINES
    if len(lines) > MAX_LINES:
        lines = lines[:MAX_LINES]

    content = "\n".join(lines) + "\n"

    out_path = project_root / "CODECLAW.md"
    out_path.write_text(content, encoding="utf-8")
    return out_path


def synthesize_for_project(project_name: str, jsonl_dir: Path | None = None) -> Path | None:
    """Load sessions from *jsonl_dir* (defaults to ~/.codeclaw/archive) and synthesize.

    Returns path to written CODECLAW.md, or None if no sessions found.
    """
    from .config import CODECLAW_DIR

    if jsonl_dir is None:
        jsonl_dir = CODECLAW_DIR / "archive"

    sessions: list[dict] = []
    if jsonl_dir.exists():
        for jsonl_file in sorted(jsonl_dir.glob("*.jsonl")):
            for session in _load_sessions_from_jsonl(jsonl_file):
                if str(session.get("project", "")).lower() == project_name.lower():
                    sessions.append(session)

    # Also check pending file
    pending = CODECLAW_DIR / "pending.jsonl"
    for session in _load_sessions_from_jsonl(pending):
        if str(session.get("project", "")).lower() == project_name.lower():
            sessions.append(session)

    if not sessions:
        return None

    # Infer project root from CWD stored in sessions
    project_root = _infer_project_root(sessions)
    if project_root is None:
        project_root = Path.cwd()

    return synthesize(sessions, project_name, project_root)


def _infer_project_root(sessions: list[dict]) -> Path | None:
    """Try to derive the project filesystem root from session metadata."""
    cwds: Counter = Counter()
    for session in sessions:
        cwd = session.get("cwd") or session.get("git_root")
        if isinstance(cwd, str) and cwd.strip():
            cwds[cwd.strip()] += 1
    if not cwds:
        return None
    most_common_cwd, _ = cwds.most_common(1)[0]
    path = Path(most_common_cwd)
    return path if path.is_dir() else None
